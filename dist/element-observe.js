var observeElement=function(e){"use strict";return e.observeElement=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.el,t=e.type,n=e.offset,o=void 0===n?.5:n,i=e.onEnter,s=void 0===i?null:i,c=e.onLeave,a=void 0===c?null:c,g=e.onProgress,l=void 0===g?null:g,u=e.rootMargin,h=void 0===u?"0px":u,v={root:null,rootMargin:h,threshold:""};switch(t){case"triggerInOutViewport":v.threshold=[0,1];break;case"triggerOnce":v.threshold=o;break;case"scrollProgress":v.threshold=b(0,1,.01)}var f=function(e,r){e.forEach((function(e){switch(t){case"triggerInOutViewport":e.isIntersecting&&s(),!e.isIntersecting&&a&&a();break;case"triggerOnce":e.isIntersecting&&(s(e.target),r.unobserve(e.target));break;case"scrollProgress":var n;n=e.intersectionRect.height/e.boundingClientRect.height,l(n)}}))},d=new IntersectionObserver(f,v);function b(e,r,t){var n=(r-e)/t;return Array.from({length:n+1},(function(r,n){return n*t+e}))}NodeList.prototype.isPrototypeOf(r)?r.forEach((function(e){return d.observe(e)})):d.observe(r)},e}({});
